/*
**	Application : Ring To Executable (Plus)
**	Purpose	    : Convert Ring project source code to executable file
**		      (Windows, Linux, macOS & FreeBSD)
**	Author	    : Mahmoud Fayed <msfclipper@yahoo.com>
**	Fork by	    : Youssef Saeed <youssefelkholey@gmail.com>
**	Date	    : 2017.11.06
**	Fork Date   : 2025
*/

/*
	Usage

		ring ring2exe.ring filename.ring [Options]
		This will set filename.ring as input to the program

		The following files will be generated:
		filename.ringo        (The Ring Object File - by Ring Compiler)
		filename.c            (The C Source code file, contains the .ringo file content)
		filename_build_*.bat  (Build script for Windows - cl, gcc, clang, tcc, etc.)
		filename_build_*.sh   (Build script for Unix - gcc, clang, etc.)
		filename.obj/.o       (Object file generated by the C compiler)
		filename.exe          (Executable File - on Windows)
		filename              (Executable File - on Linux, macOS & FreeBSD)

	Note
		We can use 
			ring ring2exe.ring ring2exe.ring 
		This will build ring2exe.exe
		We can use ring2exe.exe 

		ring2exe filename.ring 

		Or (Linux, macOS & FreeBSD)

		./ring2exe filename.ring

	Testing 	
	
		ring2exe test.ring 
		test 

		Or (Linux, macOS & FreeBSD)

		./ring2exe test.ring 
		./test

	Options

	Build Options:
		-keep            : Don't delete Temp. Files
		-static          : Build Standalone Executable (Don't use ring.dll/ring.so/ring.dylib)
		-gui             : Build GUI Application (Hide the Console Window)
		-cc=<compiler>   : Specify custom C compiler (e.g., clang, gcc)
		-cflags=<flags>  : Specify custom C compiler flags (e.g., -g)
		-output=<name>   : Specify custom output filename for the executable

	Distribution Options:
		-dist            : Prepare application for distribution
		-allruntime      : Include all libraries in distribution
		-mobileqt        : Prepare Qt Project for Mobile
		-webassemblyqt   : Prepare Qt Project for WebAssembly

	Package Format Flags (use with -dist):
		-scripts         : Generate installation scripts only (default)
		-deb             : Generate Debian package (.deb) [Linux]
		-rpm             : Generate RPM package (.rpm) [Linux]
		-appimage        : Generate AppImage package [Linux]
		-appbundle       : Generate App Bundle (.app) [macOS]
		-pkg             : Generate pkg package (.pkg) [FreeBSD]

	Library Flags:
		-<library>       : Add library to distribution (e.g., -qt, -allegro, -mysql)
		-no<library>     : Remove library from distribution (e.g., -noqt, -noallegro)

	Available Libraries:
		qt, lightguilib, allegro, openssl, libcurl, mysql, odbc, sqlite,
		postgresql, opengl, freeglut, libzip, libuv, consolecolors, 
		murmurhash, cruntime
*/

load "stdlibcore.ring"
load "tokenslib.ring"
load "/../tools/ring2exe/utils/clicolors.ring"

# Ring2EXE Plus Version
VERSION = "1.1.1"

# Load Libraries information
	aLibsInfo = []
	LoadLibrariesInfo()

func LoadLibrariesInfo
	aLibsFiles = ListAllFiles(exefolder()+"/../tools/ring2exe/libs","ring")
	for cLibFile in aLibsFiles 
		cLibFileContent = read(cLibFile)
		if ! checkRingCode([:code = cLibFileContent])
			? "The file " + cLibFile + " doesn't pass the security check!"
			loop
		ok
		eval(cLibFileContent)
		aLibsInfo + aLibrary 
	next 

func Main 
	aPara = sysargv
	aOptions = []
	cCompiler = ""
	cCompilerFlags = ""
	cOutputFileName = ""
	# Get Options
		for x = len(aPara) to 1 step -1
			cOption = lower(trim(aPara[x]))
			if left(cOption,1) = "-"
				if left(cOption,4) = "-cc="
					cCompiler = substr(cOption, 5)
					del(aPara,x)
				but left(cOption,8) = "-cflags="
					cCompilerFlags = substr(cOption, 9)
					del(aPara,x)
				but left(cOption,8) = "-output="
					cOutputFileName = substr(cOption, 9)
					aOptions + cOption
					del(aPara,x)
				else
					aOptions + cOption
					del(aPara,x)
				ok
			ok
		next
	nParaCount = len(aPara)
	if (nParaCount > 2) or ( nParaCount = 2 and aPara[1] != "ring" )
		cFile = aPara[nParaCount]
		if not fexists(cFile)
			msg("File " + cFile + " doesn't exist!")
			bye
		ok
		msg("Process File : " + cFile)
		chdir(justfilepath(cFile))
		cFile = justfilename(cFile)
		BuildApp(cFile,aOptions,cCompiler,cCompilerFlags,cOutputFileName)
	else
		PrintHelp()
	ok

func PrintHelp
	DrawLine()
	# Title
	see C_BOLD + C_BCYAN + "  Ring2EXE Plus" + C_RESET 
	? C_DIM + " v" + VERSION + " - Convert Ring Application To Executable File" + C_RESET
	see nl
	# Credits
	? C_DIM + "  Original: " + C_RESET + "Mahmoud Fayed <msfclipper@yahoo.com> (2017-2025)"
	?  C_DIM + "  Fork by:  " + C_RESET + C_BGREEN + "Youssef Saeed" + C_RESET + " <youssefelkholey@gmail.com> (2025)"
	see nl
	# Usage
	see C_BOLD + C_WHITE + "  Usage: " + C_RESET 
	? C_YELLOW + "ring2exe " + C_CYAN + "filename.ring " + C_DIM + "[options]" + C_RESET
	DrawLine()
	see nl

	# Build Options
	PrintSection("Build Options")
	PrintOption("-keep", "Don't delete Temp. Files")
	PrintOption("-static", "Build standalone executable")
	PrintOption("-gui", "Build GUI Application")
	PrintOption("-cc=<compiler>", "Specify C compiler")
	PrintOption("-cflags=<flags>", "Specify C compiler flags")
	PrintOption("-output=<name>", "Specify output filename")
	see nl

	# Distribution Options
	PrintSection("Distribution Options")
	PrintOption("-dist", "Prepare for distribution")
	PrintOption("-allruntime", "Include all libraries")
	PrintOption("-mobileqt", "Qt Project for Mobile")
	PrintOption("-webassemblyqt", "Qt Project for WebAssembly")
	see nl

	# Package Formats
	PrintSection("Package Formats " + C_DIM + "(with -dist)" + C_RESET)
	PrintOption("-scripts", "Install scripts " + C_DIM + "(default)" + C_RESET)
	PrintOption("-deb", "Debian package " + C_BBLUE + "[Linux]" + C_RESET)
	PrintOption("-rpm", "RPM package " + C_BRED + "[Linux]" + C_RESET)
	PrintOption("-appimage", "AppImage " + C_BMAGENTA + "[Linux]" + C_RESET)
	PrintOption("-appbundle", "App Bundle " + C_WHITE + "[macOS]" + C_RESET)
	PrintOption("-pkg", "pkg package " + C_BRED + "[FreeBSD]" + C_RESET)
	see nl

	# Library Flags
	PrintSection("Library Flags")
	PrintOption("-<lib>", "Include library (e.g., " + C_GREEN + "-qt" + C_RESET + ")")
	PrintOption("-no<lib>", "Exclude library (e.g., " + C_RED + "-noqt" + C_RESET + ")")
	see nl

	DrawLine()

func GetOutputName aOptions, cDefault
	# Helper to extract -output= value from options
	for x = len(aOptions) to 1 step -1
		cOption = lower(trim(aOptions[x]))
		if left(cOption, 8) = "-output="
			return substr(aOptions[x], 9)
		ok
	next
	return cDefault

func BuildApp cFileName,aOptions,cCompiler,cCompilerFlags,cOutputFileName
	msg("Start building the application...")
	
	# Generate the Object File
		systemSilent('"' + exefolder()+"../bin/ring" + '" ' + cFileName + " -go -norun")
		
	# Generate the C Source Code File
		cFile = substr(cFileName,".ring","")
		GenerateCFile(cFile,aOptions)
		
	# Generate the Batch File
		cBatch = GenerateBatch(cFile,aOptions,cCompiler,cCompilerFlags,cOutputFileName)
		
	# Build the Executable File
		msg("Build the Executable File...")
		systemSilent(cBatch)
		msg("End of building script...")
		
	# Prepare Application for distribution
		if find(aOptions,"-dist")
			Distribute(cFile,aOptions)
		else
			if CheckNoCCompiler(currentdir(),cFile,aOptions)
				if not find(aOptions,"-keep")
					ClearTempFiles(2)
				ok
				EndofBuildingMsg()
				return
			ok
		ok
		EndofBuildingMsg()
		
	# Clear Temp Files
		if not find(aOptions,"-keep")
			cleartempfiles(1)
		ok

func EndofBuildingMsg
	msg("End of building process...")

func GenerateCFile cFileName,aOptions
	# Display Message
		msg("Generate C source code file...")
	nTime = clock()
	# Convert the Ring Object File to Hex.
		cRingoFile = cFileName+".ringo"
		if not fexists(cRingoFile)
			msg("File " + cRingoFile + " doesn't exist!")
			msg("Check the source code files for compiler errors")
			bye
		ok
		cFile = read(cRingoFile)
		cHex  = str2hexCStyle(cFile)
	fp = fopen(cFileName+".c","w+")
	# Start writing the C source code - Main Function 
	if isWindows() and find(aOptions,"-gui")
		cCode = '#include "windows.h"' 	+ nl +
			'#include "stdio.h"' 	+ nl +
			'#include "stdlib.h"' 	+ nl +
			'#include "conio.h"' 	+ nl +  
			'#include "ring.h"' 	+ nl +  nl +
		'int WINAPI WinMain ( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd )' + nl +  "{" + nl + nl +
		char(9) + 'int argc;' + nl + char(9) + 'char **argv ;' + nl + 
		char(9) + 'argc = __argc ; ' + nl + char(9) + 'argv = __argv ;' + nl + nl +
		char(9) + 'static const unsigned char bytecode[] = { 
			  '
	else
		cCode = '#include "ring.h"' + nl + nl +
		'int main( int argc, char *argv[])' + nl +  "{" + nl + nl +
		char(9) + 'static const unsigned char bytecode[] = { 
			  '
	ok
	fputs(fp,cCode)
	# Add the Object File Content		
		fputs(fp,cHex)
	fputs(fp, ", EOF" + char(9) + "};"+substr(
	'

	RingState *pRingState ;
	pRingState = ring_state_new();	
	pRingState->nArgc = argc;
	pRingState->pArgv = argv;
	ring_state_runobjectstring(pRingState,(char *) bytecode,"#{f1}");
	ring_state_delete(pRingState);

	return 0;',"#{f1}",cFileName+".ring") + nl + 
	"}")
	fclose(fp)	
	msg("Generation Time : " + ((clock()-nTime)/clockspersecond()) + " seconds...")

func GenerateBatch cFileName,aOptions,cCompiler,cCompilerFlags,cOutputFileName
	msg("Generate batch|script file...")
	if find(aOptions,"-static")
		return GenerateBatchStatic(cFileName,aOptions,cCompiler,cCompilerFlags,cOutputFileName)
	else
		return GenerateBatchDynamic(cFileName,aOptions,cCompiler,cCompilerFlags,cOutputFileName)
	ok

func GenerateBatchDynamic cFileName,aOptions,cCompiler,cCompilerFlags,cOutputFileName
	msg("Generate batch|script file for dynamic building...")
	return GenerateBatchGeneral([
		:file = cFileName ,
		:ringlib = [
			:windows = exefolder() + "..\lib\ring.lib" ,
			:linux   = "-L "+exefolder()+"/../lib -lring",
			:macosx	 = exefolder() + "/../lib/libring.dylib",
			:freebsd = "-L "+exefolder()+"/../lib -lring"
		]
	],aOptions,cCompiler,cCompilerFlags,cOutputFileName)

func GenerateBatchStatic cFileName,aOptions,cCompiler,cCompilerFlags,cOutputFileName
	msg("Generate batch|script file for static building...")
	return GenerateBatchGeneral([
		:file = cFileName ,
		:ringlib = [
			:windows = exefolder()+"..\lib\ringstatic.lib" ,
			:linux   = "-static -L "+exefolder()+"/../lib -lringstatic",
			:macosx	 = "-L "+exefolder()+"/../lib -lringstatic",
			:freebsd = "-static -L "+exefolder()+"/../lib -lringstatic"
		]
	],aOptions,cCompiler,cCompilerFlags,cOutputFileName)


func GenerateBatchGeneral aPara,aOptions,cCompiler,cCompilerFlags,cOutputFileName
	cFileName = aPara[:file]
	cFile = substr(cFileName," ","_")
	# Determine output filename
	cOutput = cFile
	if cOutputFileName != NULL
		cOutput = cOutputFileName
	ok
	# Generate Windows Batch
	if isWindows()
		cBuildtarget = getarch()
		if cBuildtarget = "unknown"
			cBuildtarget = "x86"
		ok
		cComp = "cl"
		if cCompiler != NULL
			cComp = cCompiler
		ok
		
		# Check if using MSVC (cl) or other compilers (gcc, clang, tcc)
		if cComp = "cl"
			# Visual C++ syntax
			cFlags = "/O2"
			if cCompilerFlags != NULL
				cFlags = cCompilerFlags
			ok
			cCode = "setlocal enableextensions enabledelayedexpansion" + nl + 'call "'+exefolder()+'../language/build/locatevc.bat" ' + cBuildtarget + nl +
				"#{f3}" + nl +
				cComp + ' ' + cFlags + ' "#{f1}.c" "#{f2}" #{f4} -I"#{f6}..\language\include" -I"#{f6}../language/src/" /link #{f5} /out:"#{f7}"' + nl +
				"endlocal" + nl
			# GUI Application
			if find(aOptions,"-gui")
				cLinkFlags = 'advapi32.lib shell32.lib /STACK:8388608 /SUBSYSTEM:WINDOWS,"5.01" '
			else
				cLinkFlags = ' /STACK:8388608 /SUBSYSTEM:CONSOLE,"5.01" '
			ok
		else
			# GCC/Clang/TCC syntax
			cFlags = "-O2"
			if cCompilerFlags != NULL
				cFlags = cCompilerFlags
			ok
			cCode = cComp + ' ' + cFlags + ' "#{f1}.c" "#{f2}" #{f4} -I"#{f6}../language/include" -I"#{f6}../language/src/" -o "#{f7}" #{f5}' + nl
			# GUI Application
			if find(aOptions,"-gui")
				cLinkFlags = '-ladvapi32 -lshell32 -mwindows'
			else
				cLinkFlags = ''
			ok
		ok
		
		cCode = substr(cCode,"#{f1}",cFile)
		cCode = substr(cCode,"#{f2}",aPara[:ringlib][:windows])
		# Resource File
			cResourceFile = cFile + ".rc"
			if fexists(cResourceFile)
				if cComp = "cl"
					cCode = substr(cCode,"#{f3}","rc " + cResourceFile)
					cCode = substr(cCode,"#{f4}",cFile + ".res")
				else
					cCode = substr(cCode,"#{f3}","windres " + cResourceFile + " -o " + cFile + ".res")
					cCode = substr(cCode,"#{f4}",cFile + ".res")
				ok
			else
				cCode = substr(cCode,"#{f3}","")
				cCode = substr(cCode,"#{f4}","")
			ok
		cCode = substr(cCode,"#{f5}",cLinkFlags)
		cCode = substr(cCode,"#{f6}",exefolder())
		cCode = substr(cCode,"#{f7}",cOutput + ".exe")
		cWindowsBatch = cFile+"_build_"+cComp+".bat"
		write(cWindowsBatch,cCode)
	# Generate Linux Script (GNU C/C++)
	but isLinux()
		cComp = "gcc"
		if cCompiler != NULL
			cComp = cCompiler
		ok
		cFlags = "-O2"
		if cCompilerFlags != NULL
			cFlags = cCompilerFlags
		ok
		cCode = cComp + ' ' + cFlags + ' #{f1}.c -o #{f4} #{f2} -lm -ldl  -I #{f3}/../language/include  '
		cCode = substr(cCode,"#{f1}",cFile)
		cCode = substr(cCode,"#{f2}",aPara[:ringlib][:linux])
		cCode = substr(cCode,"#{f3}",exefolder())
		cCode = substr(cCode,"#{f4}",cOutput)
		cLinuxBatch = cFile+"_build_"+cComp+".sh"
		write(cLinuxBatch,cCode)
	# Generate macOS Script (CLang C/C++)
	but isMacosx()
		cComp = "clang"
		if cCompiler != NULL
			cComp = cCompiler
		ok
		cFlags = "-O2"
		if cCompilerFlags != NULL
			cFlags = cCompilerFlags
		ok
		cCode = cComp + ' ' + cFlags + ' #{f1}.c #{f2} -o #{f4} -lm -ldl  -I #{f3}/../language/include  '
		cCode = substr(cCode,"#{f1}",cFile)
		cCode = substr(cCode,"#{f2}",aPara[:ringlib][:macosx])
		cCode = substr(cCode,"#{f3}",exefolder())
		cCode = substr(cCode,"#{f4}",cOutput)
		cMacOSXBatch = cFile+"_build_"+cComp+".sh"
		write(cMacOSXBatch,cCode)
	# Generate FreeBSD Script (CLang C/C++)
	but isFreeBSD()
		cComp = "clang"
		if cCompiler != NULL
			cComp = cCompiler
		ok
		cFlags = "-O2"
		if cCompilerFlags != NULL
			cFlags = cCompilerFlags
		ok
		cCode = cComp + ' ' + cFlags + ' #{f1}.c #{f2} -o #{f4} -lm -ldl  -I #{f3}/../language/include  '
		cCode = substr(cCode,"#{f1}",cFile)
		cCode = substr(cCode,"#{f2}",aPara[:ringlib][:freebsd])
		cCode = substr(cCode,"#{f3}",exefolder())
		cCode = substr(cCode,"#{f4}",cOutput)
		cFreeBSDBatch = cFile+"_build_"+cComp+".sh"
		write(cFreeBSDBatch,cCode)
	ok
	# Return the script/batch file name
		if isWindows()
			return cWindowsBatch
		but isLinux()
			systemSilent("chmod +x " + cLinuxBatch)
			return "./"+cLinuxBatch
		but isMacosx()
			systemSilent("chmod +x " + cMacOSXBatch)
			return "./"+cMacOSXBatch
		but isFreeBSD()
			systemSilent("chmod +x " + cFreeBSDBatch)
			return "./"+cFreeBSDBatch
		ok

func ClearTempFiles nPara
	msg("Clear Temp. Files...")
	
	# Get list of files to clean up
	aFiles = dir(currentdir())
	
	for aFile in aFiles
		if aFile[2] = 0
			cFileName = aFile[1]
			
			# Remove C source file
			if right(cFileName, 2) = ".c"
				cBaseName = substr(cFileName, 1, len(cFileName)-2)
				cRingoFile = cBaseName + ".ringo"
				if fexists(cRingoFile)
					remove(cFileName)
				ok
				loop
			ok
			
			# Remove build scripts based on compiler (e.g., test_build_gcc.sh, test_build_cl.bat)
			if (right(cFileName, 4) = ".bat" or right(cFileName, 3) = ".sh") and substr(cFileName, "_build_")
				remove(cFileName)
				loop
			ok
			
			# Windows-specific files
			if isWindows()
				cExt = lower(right(cFileName, 4))
				if cExt = ".obj" or cExt = ".exp" or cExt = ".lib"
					remove(cFileName)
					loop
				ok
			ok
		ok
	next

	if nPara = 1
		for aFile in aFiles
			if aFile[2] = 0
				cFileName = aFile[1]
				if right(cFileName, 6) = ".ringo"
					remove(cFileName)
				ok
			ok
		next
	ok


func Distribute cFileName,aOptions
	cBaseFolder = currentdir()
	# Get custom output filename if specified
	cOutput = cFileName
	for x = len(aOptions) to 1 step -1
		cOption = lower(trim(aOptions[x]))
		if left(cOption,8) = "-output="
			cOutput = substr(cOption, 9)
			exit
		ok
	next
	OSCreateOpenFolder(:target)
	if find(aOptions,"-mobileqt")
		# Prepare Application for Mobile (RingQt)
		DistributeForMobileQt(cBaseFolder,cFileName,aOptions)
	but find(aOptions,"-webassemblyqt")
		# Prepare Application for WebAssembly (RingQt)
		DistributeForWebAssemblyQt(cBaseFolder,cFileName,aOptions)
	but isWindows()
		DistributeForWindows(cBaseFolder,cFileName,aOptions)
	but isLinux()
		DistributeForLinux(cBaseFolder,cFileName,aOptions)
	but isMacOSX()
		DistributeForMacOSX(cBaseFolder,cFileName,aOptions)
	but isFreeBSD()
		DistributeForFreeBSD(cBaseFolder,cFileName,aOptions)
	ok
	# Delete the executable file
		if isWindows()
			OSDeleteFile(cBaseFolder+"\"+cOutput+".exe")
		else
			OSDeleteFile(cBaseFolder+"/"+cOutput)
		ok
	chdir(cBaseFolder)

func DistributeForWindows cBaseFolder,cFileName,aOptions
	# Delete Files 
	if direxists(:windows)
		OSDeleteFolder(:windows)
	ok
	OSCreateOpenFolder(:windows)
	# copy the executable file
		msg("Copy the executable file to target/windows")
		cOutput = GetOutputName(aOptions, cFileName)
		OSCopyFile(cBaseFolder+"\\"+cOutput+".exe")
		CheckNoCCompiler(cBaseFolder,cOutput,aOptions)
	# Check ring.dll
		if not find(aOptions,"-static")	
			msg("Copy ring.dll to target/windows")	
			OSCopyFile(exefolder()+"\ring.dll")
		ok
	# Check All Runtime 
		if find(aOptions,"-allruntime")	
			msg("Copy all libraries to target/windows")	
			for aLibrary in aLibsInfo 
				if not find(aOptions,"-no"+aLibrary[:name])
					msg("Copy library files: "+aLibrary[:title])
					if islist(aLibrary[:windowsfolders])
						for cLibFolder in aLibrary[:windowsfolders]
							msg("Copy folder: "+cLibFolder)
							OSCopyFolder(exefolder(),cLibFolder)
						next
					ok
					if islist(aLibrary[:windowsfiles])
						for cLibFile in aLibrary[:windowsfiles]
							msg("Copy file: "+cLibFile)
							custom_OSCopyFile(exefolder(),cLibFile)
						next
					ok
				else 
					msg("Skip library "+aLibrary[:title])
				ok
			next  	
		else	# No -allruntime
			for aLibrary in aLibsInfo 
				if find(aOptions,"-"+aLibrary[:name])
					msg("Add "+aLibrary[:title]+" to target/windows")
					if islist(aLibrary[:windowsfolders])
						for cLibFolder in aLibrary[:windowsfolders]
							msg("Copy folder: "+cLibFolder)
							OSCopyFolder(exefolder(),cLibFolder)
						next
					ok
					if islist(aLibrary[:windowsfiles])
						for cLibFile in aLibrary[:windowsfiles]
							msg("Copy file: "+cLibFile)
							custom_OSCopyFile(exefolder(),cLibFile)
						next
					ok
				ok
			next 				
		ok
	# Copy Files (Images, etc) in Resources File
		CheckQtResourceFile(cBaseFolder,cFileName,aOptions)

func ShouldGeneratePackage aOptions, cPackageType
	# Check if any specific package format flag is provided
	lHasSpecificFlag = find(aOptions,"-scripts") or find(aOptions,"-deb") or
	                   find(aOptions,"-rpm") or find(aOptions,"-appimage") or
	                   find(aOptions,"-appbundle") or find(aOptions,"-pkg")
	if lHasSpecificFlag
		# User specified explicit package types
		return find(aOptions, "-" + cPackageType)
	else
		# Default behavior: only generate scripts
		return cPackageType = "scripts"
	ok

func DistributeForLinux cBaseFolder,cFileName,aOptions
	# Delete Files
	if direxists(:linux)
		OSDeleteFolder(:linux)
	ok
	OSCreateOpenFolder(:linux)
	cLinuxDir = currentdir()
	cAppName = substr(cFileName," ","_")
	cDebDir = ""
	cRpmDir = ""
	# Conditionally create package directories
	if ShouldGeneratePackage(aOptions, "deb")
		OSCreateOpenFolder("dist_using_deb_package")
		cDebDir = currentdir()
		chdir(cLinuxDir)
	ok
	if ShouldGeneratePackage(aOptions, "rpm")
		OSCreateOpenFolder("dist_using_rpm_package")
		cRpmDir = currentdir()
		chdir(cLinuxDir)
	ok
	# Always create scripts directory (needed as base for other packages too)
	OSCreateOpenFolder("dist_using_scripts")
	cDir = currentdir()
	OSCreateOpenFolder(:bin)
	# copy the executable file
		msg("Copy the executable file to target/linux/bin")
		cOutput = GetOutputName(aOptions, cFileName)
		OSCopyFile(cBaseFolder+"/"+cOutput)
		CheckNoCCompiler(cBaseFolder,cOutput,aOptions)
	# Copy Files (Images, etc) in Resources File
		CheckQtResourceFile(cBaseFolder,cFileName,aOptions)
	chdir(cDir)
	OSCreateOpenFolder(:lib)
	cInstallUbuntu = "sudo apt-get install"
	cInstallFedora = "sudo dnf install"
	cInstallLibs   = ""
	cDebianPackageDependency = ""
	# Check ring.so
		if not find(aOptions,"-static")	
			msg("Copy libring.so to target/linux/lib")	
			OSCopyFile(exefolder()+"/../lib/libring.so")
		ok
		cInstallLibs = InstallLibLinux(cInstallLibs,"libring.so")
	# Check All Runtime 
		if find(aOptions,"-allruntime")	
			msg("Copy all libraries to target/linux/lib")
			OSCopyFile(exefolder()+"/../lib/libring.so")	
			for aLibrary in aLibsInfo 
				if not find(aOptions,"-no"+aLibrary[:name])
					if islist(aLibrary[:linuxfiles])
						for cLibFile in aLibrary[:linuxfiles]
							msg("Copy file: "+cLibFile)
							OSCopyFile(exefolder()+"/../lib/"+cLibFile)					
							cInstallLibs = InstallLibLinux(cInstallLibs,cLibFile)
						next
					ok
					cInstallUbuntu += (" " + aLibrary[:ubuntudep])
					cInstallFedora += (" " + aLibrary[:fedoradep])
					if aLibrary[:ubuntudep] != NULL
						cDebianPackageDependency += (" " + aLibrary[:ubuntudep])			
					ok
				else 
					msg("Skip library "+aLibrary[:title])
				ok
			next  	
		else	# No -allruntime
			for aLibrary in aLibsInfo 
				if find(aOptions,"-"+aLibrary[:name])
					msg("Add "+aLibrary[:title]+" to target/linux/lib")
					if islist(aLibrary[:linuxfiles])
						for cLibFile in aLibrary[:linuxfiles]
							msg("Copy file: "+cLibFile)
							OSCopyFile(exefolder()+"/../lib/"+cLibFile)
							cInstallLibs = InstallLibLinux(cInstallLibs,cLibFile)
						next
					ok
					cInstallUbuntu += (" " + aLibrary[:ubuntudep])
					cInstallFedora += (" " + aLibrary[:fedoradep])					
					if aLibrary[:ubuntudep] != NULL
						cDebianPackageDependency += (" " + aLibrary[:ubuntudep])			
					ok
				ok
			next 				
		ok
	# Script to install the application
	chdir(cDir)
	# Create installation script content
	cInstallApp = "
echo 'Installing application...'
sudo mkdir -p /usr/local/bin
sudo mkdir -p /usr/local/lib
sudo cp bin/" + cOutput + " /usr/local/bin/
echo 'Executable installed to /usr/local/bin/" + cOutput + "'
" + cInstallLibs + "
echo 'Installation completed successfully!'
echo 'You can now run: " + cOutput + "'
"
	cInstallApp = RemoveFirstTabs(cInstallApp,1)
	
	# Always create installation scripts with full installation commands
	if cInstallUbuntu != "sudo apt-get install"
		cInstallUbuntu += nl + cInstallApp
	else
		cInstallUbuntu = "#!/bin/bash" + nl + "echo 'Installing dependencies...'" + nl + "echo 'No additional dependencies required.'" + nl + cInstallApp
	ok
	write("install_ubuntu.sh",cInstallUbuntu)
	SystemSilent("chmod +x install_ubuntu.sh")
	
	if cInstallFedora != "sudo dnf install"
		cInstallFedora += nl + cInstallApp
	else
		cInstallFedora = "#!/bin/bash" + nl + "echo 'Installing dependencies...'" + nl + "echo 'No additional dependencies required.'" + nl + cInstallApp
	ok
	write("install_fedora.sh",cInstallFedora)
	SystemSilent("chmod +x install_fedora.sh")
	# Create the AppImage package
	if ShouldGeneratePackage(aOptions, "appimage")
		chdir(cLinuxDir)
		CreateAppImage(cOutput, aOptions)
	ok
	
	# Create the debian package
	if ShouldGeneratePackage(aOptions, "deb")
	msg("Prepare files to create the Debian package")
	chdir(cDebDir)
	# Get custom output filename for package name
	cPackageName = cAppName
	for x = len(aOptions) to 1 step -1
		cOption = lower(trim(aOptions[x]))
		if left(cOption,8) = "-output="
			cPackageName = substr(cOption, 9)
			cPackageName = substr(cPackageName," ","_")
			exit
		ok
	next
	cBuildDeb = "dpkg-deb --build #{f1}_1.0-1"
	cBuildDeb = substr(cBuildDeb,"#{f1}",cPackageName)
	write("builddeb.sh",cBuildDeb)
	SystemSilent("chmod +x builddeb.sh")
	OSCreateOpenFolder(cPackageName+"_1.0-1")
	cAppFolder = currentdir()
	OSCreateOpenFolder("DEBIAN")
	cControl = RemoveFirstTabs("Package: #{f1}
		Version: 1.0-1
		Section: base
		Priority: optional
		Architecture: #{f3}
		Depends: #{f2}
		Maintainer: Developer Name <youraccount@email.com>
		Description: Ring Application",2) + nl
	cDebianPackageDependency = trim(cDebianPackageDependency)
	if cDebianPackageDependency != NULL
		cDebianPackageDependency = substr(cDebianPackageDependency," "," (>=0) ,")
		cDebianPackageDependency += " (>=0) "
	ok
	cControl = substr(cControl,"#{f1}",cPackageName)
	cControl = substr(cControl,"#{f2}",cDebianPackageDependency)
	cControl = substr(cControl,"#{f3}",GetPackageArch("deb"))
	write("control",cControl)
	cPostInst = RemoveFirstTabs("#!/bin/sh
		cd /usr/local/#{f1}/bin
		./#{f2}
		exit 0
	",2)
	cPostInst = substr(cPostInst,"#{f1}",cPackageName)
	# Get the actual executable name for postinst
	cExecName = cOutput
	cPostInst = substr(cPostInst,"#{f2}",cExecName)
	write("postinst",cPostInst)
	SystemSilent("chmod +x postinst")
	chdir(cAppFolder)
	OSCreateOpenFolder("usr")
		cUsrFolder = currentdir()
		OSCreateOpenFolder("bin")
		# Create wrapper script with custom output name
		write(cOutput,"/usr/local/"+cPackageName+"/bin/"+cOutput+" \$1 \$2 \$3 \$4 \$5 \$6 \$7")
		systemSilent("chmod +x " + cOutput)
		chdir(cUsrFolder)
		OSCreateOpenFolder("lib")
		chdir(cUsrFolder)
		OSCreateOpenFolder("local")
			OSCreateOpenFolder(cPackageName)
				OSCreateOpenFolder("bin")
	chdir(cAppFolder)
	systemSilent("cp -a ../../dist_using_scripts/lib/. usr/lib/")
	systemSilent("cp -a ../../dist_using_scripts/bin/. usr/local/"+cPackageName+"/bin/")
	ok
	
	# Create the RPM package
	if ShouldGeneratePackage(aOptions, "rpm")
		msg("Prepare files to create the RPM package")
		chdir(cRpmDir)
		# Get custom output filename for package name
		cRpmPackageName = cAppName
		for x = len(aOptions) to 1 step -1
			cOption = lower(trim(aOptions[x]))
			if left(cOption,8) = "-output="
				cRpmPackageName = substr(cOption, 9)
				cRpmPackageName = substr(cRpmPackageName," ","_")
				exit
			ok
		next
		cBuildRpm = "rpmbuild -bb --define '_topdir #{f1}' --define '_builddir #{f1}/BUILD' --define '_rpmdir #{f1}/RPMS' --define '_sourcedir #{f1}/SOURCES' --define '_specdir #{f1}/SPECS' --define '_srcrpmdir #{f1}/SRPMS' --target #{f3} #{f2}.spec"
		cBuildRpm = substr(cBuildRpm,"#{f1}",currentdir())
		cBuildRpm = substr(cBuildRpm,"#{f2}",cRpmPackageName)
		cBuildRpm = substr(cBuildRpm,"#{f3}",GetPackageArch("rpm"))
		write("buildrpm.sh",cBuildRpm)
		SystemSilent("chmod +x buildrpm.sh")
		
		# Create RPM directory structure
		OSCreateOpenFolder("BUILD")
		chdir(cRpmDir)
		OSCreateOpenFolder("RPMS")
		chdir(cRpmDir)
		OSCreateOpenFolder("SOURCES")
		chdir(cRpmDir)
		OSCreateOpenFolder("SPECS")
		chdir(cRpmDir)
		OSCreateOpenFolder("SRPMS")
		chdir(cRpmDir)
		OSCreateOpenFolder("BUILDROOT")
		cBuildRootDir = currentdir() + "/" + cRpmPackageName + "-1.0-1." + GetPackageArch("rpm")
		OSCreateOpenFolder(cRpmPackageName + "-1.0-1." + GetPackageArch("rpm"))
		chdir(cBuildRootDir)
		OSCreateOpenFolder("usr")
		chdir(cBuildRootDir + "/usr")
		OSCreateOpenFolder("local")
		chdir(cBuildRootDir + "/usr/local")
		OSCreateOpenFolder("bin")
		chdir(cBuildRootDir + "/usr/local/bin")
		# Copy executable
		cRpmOutput = cOutput
		OSCopyFile(cLinuxDir + "/dist_using_scripts/bin/" + cRpmOutput)
		chdir(cBuildRootDir + "/usr")
		OSCreateOpenFolder("lib64")
		chdir(cBuildRootDir + "/usr/lib64")
		# Copy libraries
		systemSilent("cp -a " + cLinuxDir + "/dist_using_scripts/lib/. .")
		
		# Generate RPM dependencies list
		cRpmRequires = ""
		if find(aOptions,"-allruntime")
			for aLibrary in aLibsInfo
				if not find(aOptions,"-no"+aLibrary[:name])
					if aLibrary[:fedoradep] != NULL
						if len(cRpmRequires) > 0 cRpmRequires += ", " ok
						cRpmRequires += aLibrary[:fedoradep]
					ok
				ok
			next
		else	# No -allruntime
			for aLibrary in aLibsInfo
				if find(aOptions,"-"+aLibrary[:name])
					if aLibrary[:fedoradep] != NULL
						if cRpmRequires != NULL cRpmRequires += ", " ok
						cRpmRequires += aLibrary[:fedoradep]
					ok
				ok
			next
		ok
		
		# Generate RPM spec file
		chdir(cRpmDir)
		# Build requires line conditionally
		cRequiresLine = ""
		if len(cRpmRequires) > 0
			cRequiresLine = "Requires: " + cRpmRequires + nl
		ok
		
		cRpmSpec = RemoveFirstTabs("Name: #{f1}
			Version: 1.0
			Release: 1%{?dist}
			Summary: Ring Application
			License: MIT
			URL: https://ring-lang.net
			BuildArch: %{_arch}
			Prefix: /usr
			AutoReq: no
			#{f2}
			%description
			Ring Application built with Ring2EXE
			
			%files
			/usr/local/bin/#{f3}
			/usr/lib64/*
			
			%changelog
			* #{f4}
			- Initial RPM package
		",3)
		
		# Get current date for changelog
		aTimeList = TimeList()
		cCurrentDate = aTimeList[1] + " " + aTimeList[3] + " " + aTimeList[6] + " " + aTimeList[19]
		
		# Format: * Day Mon DD YYYY Name <email> - Version-Release
		cChangelogLine = cCurrentDate + " Developer Name <youraccount@email.com> - 1.0-1"
		
		cRpmSpec = substr(cRpmSpec,"#{f1}",cRpmPackageName)
		cRpmSpec = substr(cRpmSpec,"#{f2}",cRequiresLine)
		cRpmSpec = substr(cRpmSpec,"#{f3}",cRpmOutput)
		cRpmSpec = substr(cRpmSpec,"#{f4}",cChangelogLine)
		write(cRpmPackageName + ".spec",cRpmSpec)
	ok

func InstallLibLinux cInstallLib,cLibFile 
	cCode = "
		if [ -f lib/#{f1} ];
		then
			sudo cp lib/#{f1} /usr/lib
			sudo cp lib/#{f1} /usr/lib64
		fi
	"
	cCode = SubStr(cCode,"#{f1}",cLibFile)
	cCode = RemoveFirstTabs(cCode,2)
	return cInstallLib + cCode

func RemoveFirstTabs cString,nCount
	aList = str2list(cString)
	for item in aList 
		if left(item,nCount) = Copy(char(9),nCount)
			if len(item) > nCount
				item = substr(item,nCount+1)
			ok
		ok
	next
	return list2str(aList)

func DistributeForMacOSX cBaseFolder,cFileName,aOptions
	# Delete Files
	if direxists(:macosx)
		OSDeleteFolder(:macosx)
	ok
	OSCreateOpenFolder(:macosx)
	cMacosxDir = currentdir()
	OSCreateOpenFolder("dist_using_scripts")
	cDistScriptsDir = currentdir()
	OSCreateOpenFolder(:bin)
	# copy the executable file
		msg("Copy the executable file to target/macosx/dist_using_scripts/bin")
		cOutput = GetOutputName(aOptions, cFileName)
		OSCopyFile(cBaseFolder+"/"+cOutput)
		CheckNoCCompiler(cBaseFolder,cOutput,aOptions)
	# Copy Files (Images, etc) in Resources File
		CheckQtResourceFile(cBaseFolder,cFileName,aOptions)
	chdir(cDistScriptsDir)
	OSCreateOpenFolder(:lib)
	cInstallmacosx = "brew install -k"
	cInstallLibs   = ""
	# Check ring.dylib
		if not find(aOptions,"-static")
			msg("Copy libring.dylib to target/macosx/dist_using_scripts/lib")
			OSCopyFile(exefolder()+"/../lib/libring.dylib")
		ok
		cInstallLibs = InstallLibMacOSX(cInstallLibs,"libring.dylib")
	# Check All Runtime
		if find(aOptions,"-allruntime")
			msg("Copy all libraries to target/macosx/dist_using_scripts/lib")
			OSCopyFile(exefolder()+"/../lib/libring.dylib")
			for aLibrary in aLibsInfo
				if not find(aOptions,"-no"+aLibrary[:name])
					if islist(aLibrary[:macosxfiles])
						for cLibFile in aLibrary[:macosxfiles]
							OSCopyFile(exefolder()+"/../lib/"+cLibFile)
							cInstallLibs = InstallLibMacOSX(cInstallLibs,cLibFile)
						next
					ok
					cInstallmacosx += (" " + aLibrary[:macosxdep])
				else
					msg("Skip library "+aLibrary[:title])
				ok
			next
		else	# No -allruntime
			for aLibrary in aLibsInfo
				if find(aOptions,"-"+aLibrary[:name])
					msg("Add "+aLibrary[:title]+" to target/macosx/dist_using_scripts/lib")
					if islist(aLibrary[:macosxfiles])
						for cLibFile in aLibrary[:macosxfiles]
							OSCopyFile(exefolder()+"/../lib/"+cLibFile)
							cInstallLibs = InstallLibMacOSX(cInstallLibs,cLibFile)
						next
					ok
					cInstallmacosx += (" " + aLibrary[:macosxdep])
				ok
			next
		ok
	# Script to install the application
	chdir(cMacosxDir+"/dist_using_scripts")
	cInstallApp = "
	echo 'Installing application...'
	sudo mkdir -p /usr/local/bin
	sudo mkdir -p /usr/local/lib
	sudo cp bin/" + cOutput + " /usr/local/bin/
	echo 'Executable installed to /usr/local/bin/" + cOutput + "'
	" + cInstallLibs + "
	echo 'Installation completed successfully!'
	echo 'You can now run: " + cOutput + "'
	"
	cInstallApp = RemoveFirstTabs(cInstallApp,1)
	if cInstallmacosx != "brew install -k"
		cInstallmacosx += nl + cInstallApp
	else
		cInstallmacosx = "#!/bin/bash" + nl + "echo 'Installing dependencies...'" + nl + "echo 'No additional dependencies required.'" + nl + cInstallApp
	ok
	write("install.sh",cInstallmacosx)
	SystemSilent("chmod +x install.sh")
	
	# Create App Bundle with distribution (if -appbundle flag is specified or no specific flags)
	if ShouldGeneratePackage(aOptions, "appbundle")
		chdir(cMacosxDir)
		CreateAppBundle(cOutput, aOptions)
	ok

func InstallLibMacOSX cInstallLib,cLibFile
	cCode = "
		if [ -f lib/#{f1} ];
		then
			sudo cp lib/#{f1} /usr/local/lib
		fi
	"
	cCode = SubStr(cCode,"#{f1}",cLibFile)
	cCode = RemoveFirstTabs(cCode,2)
	return cInstallLib + cCode

func InstallLibFreeBSD cInstallLib,cLibFile
	cCode = "
		if [ -f lib/#{f1} ];
		then
			sudo cp lib/#{f1} /usr/local/lib
		fi
	"
	cCode = SubStr(cCode,"#{f1}",cLibFile)
	cCode = RemoveFirstTabs(cCode,2)
	return cInstallLib + cCode

func DistributeForFreeBSD cBaseFolder,cFileName,aOptions
	cAppName = substr(cFileName," ","_")
	# Delete Files
	if direxists(:freebsd)
		OSDeleteFolder(:freebsd)
	ok
	OSCreateOpenFolder(:freebsd)
	cFreeBSDDir = currentdir()
	cPkgDir = ""
	# Conditionally create pkg directory
	if ShouldGeneratePackage(aOptions, "pkg")
		OSCreateOpenFolder("dist_using_pkg")
		cPkgDir = currentdir()
		chdir(cFreeBSDDir)
	ok
	# Always create scripts directory
	OSCreateOpenFolder("dist_using_scripts")
	cDir = currentdir()
	OSCreateOpenFolder(:bin)
	# copy the executable file
		msg("Copy the executable file to target/freebsd/dist_using_scripts/bin")
		cOutput = GetOutputName(aOptions, cAppName)
		OSCopyFile(cBaseFolder+"/"+cOutput)
		CheckNoCCompiler(cBaseFolder,cOutput,aOptions)
	# Copy Files (Images, etc) in Resources File
		CheckQtResourceFile(cBaseFolder,cAppName,aOptions)
	chdir(cDir)
	OSCreateOpenFolder(:lib)
	cInstallFreeBSD = "sudo pkg install -y"
	cInstallLibs   = ""
	cPkgDepString = ""
	# Check libring.so
		if not find(aOptions,"-static")
			msg("Copy libring.so to target/freebsd/dist_using_scripts/lib")
			OSCopyFile(exefolder()+"/../lib/libring.so")
		ok
		cInstallLibs = InstallLibFreeBSD(cInstallLibs,"libring.so")
	# Check All Runtime
		if find(aOptions,"-allruntime")
			msg("Copy all libraries to target/freebsd/dist_using_scripts/lib")
			OSCopyFile(exefolder()+"/../lib/libring.so")
			for aLibrary in aLibsInfo
				if not find(aOptions,"-no"+aLibrary[:name])
					if islist(aLibrary[:freebsdfiles])
						for cLibFile in aLibrary[:freebsdfiles]
							msg("Copy file: "+cLibFile)
							OSCopyFile(exefolder()+"/../lib/"+cLibFile)
							cInstallLibs = InstallLibFreeBSD(cInstallLibs,cLibFile)
						next
					else
						if islist(aLibrary[:linuxfiles])
							for cLibFile in aLibrary[:linuxfiles]
								msg("Copy file: "+cLibFile)
								OSCopyFile(exefolder()+"/../lib/"+cLibFile)
								cInstallLibs = InstallLibFreeBSD(cInstallLibs,cLibFile)
							next
						ok
					ok
					if aLibrary[:freebsddep] != NULL
						cInstallFreeBSD += (" " + aLibrary[:freebsddep])
						if cPkgDepString != NULL cPkgDepString += "," ok
						cPkgDepString += '"' + aLibrary[:freebsddep] + '": { "origin": "misc/' + aLibrary[:freebsddep] + '" }'
					ok
				else
					msg("Skip library "+aLibrary[:title])
				ok
			next
		else	# No -allruntime
			for aLibrary in aLibsInfo
				if find(aOptions,"-"+aLibrary[:name])
					msg("Add "+aLibrary[:title]+" to target/freebsd/dist_using_scripts/lib")
					if islist(aLibrary[:freebsdfiles])
						for cLibFile in aLibrary[:freebsdfiles]
							msg("Copy file: "+cLibFile)
							OSCopyFile(exefolder()+"/../lib/"+cLibFile)
							cInstallLibs = InstallLibFreeBSD(cInstallLibs,cLibFile)
						next
					else
						if islist(aLibrary[:linuxfiles])
							for cLibFile in aLibrary[:linuxfiles]
								msg("Copy file: "+cLibFile)
								OSCopyFile(exefolder()+"/../lib/"+cLibFile)
								cInstallLibs = InstallLibFreeBSD(cInstallLibs,cLibFile)
							next
						ok
					ok
					if aLibrary[:freebsddep] != NULL
						cInstallFreeBSD += (" " + aLibrary[:freebsddep])
						if cPkgDepString != NULL cPkgDepString += "," ok
						cPkgDepString += '"' + aLibrary[:freebsddep] + '": { "origin": "misc/' + aLibrary[:freebsddep] + '" }'
					ok
				ok
			next
		ok
	# Script to install the application
	chdir(cDir)
	if cInstallFreeBSD != "sudo pkg install -y"
		cInstallFreeBSD += (nl+cInstallLibs)
		write("install.sh",cInstallFreeBSD)
		SystemSilent("chmod +x install.sh")
	ok
	# Create the pkg package
	if ShouldGeneratePackage(aOptions, "pkg")
	msg("Prepare files to create the pkg package")
	chdir(cPkgDir)
	cBuildPkg = "pkg create -m . -r stage -o ."
	write("buildpkg.sh",cBuildPkg)
	SystemSilent("chmod +x buildpkg.sh")
	OSCreateOpenFolder("stage")
	chdir(cPkgDir+"/stage")
	OSCreateOpenFolder("usr")
	chdir(cPkgDir+"/stage/usr")
	OSCreateOpenFolder("local")
	chdir(cPkgDir+"/stage/usr/local")
	cLocalDir = currentdir()
	OSCreateOpenFolder("bin")
	chdir(cLocalDir+"/bin")
	cOutput = GetOutputName(aOptions, cAppName)
	OSCopyFile(cFreeBSDDir+"/dist_using_scripts/bin/"+cOutput)
	chdir(cLocalDir)
	OSCreateOpenFolder("lib")
	chdir(cLocalDir+"/lib")
	systemSilent("cp -a "+cFreeBSDDir+"/dist_using_scripts/lib/. .")
	chdir(cPkgDir)
	# Generate files list
	# Get custom output filename for FreeBSD package
	cPkgExecName = cOutput
	for x = len(aOptions) to 1 step -1
		cOption = lower(trim(aOptions[x]))
		if left(cOption,8) = "-output="
			cPkgExecName = substr(cOption, 9)
			exit
		ok
	next
	cFilesString = '"/usr/local/bin/' + cPkgExecName + '": "0755"'
	cLibDir = cFreeBSDDir+"/dist_using_scripts/lib/"
	aLibFiles = dir(cLibDir)
	for item in aLibFiles
		if not item[1]
			cLibFile = item[2]
			if cLibFile = "." or cLibFile = ".." continue ok
			cFilesString += ',"/usr/local/lib/' + cLibFile + '": "0644"'
		ok
	next
	# Generate +MANIFEST
	cDesc = "Ring Application"
	cManifest = '
{
	"name": "' + cAppName + '",
	"version": "1.0",
	"origin": "misc/' + cAppName + '",
	"arch": "' + GetPackageArch("pkg") + '",
	"comment": "Ring Application",
	"desc": "' + cDesc + '",
	"maintainer": "Developer Name <youraccount@email.com>",
	"www": "https://ring-lang.net",
	"prefix": "/usr/local",
	"licenselogic": "single",
	"licenses": [ "MIT" ],
	"files": {
		' + cFilesString + '
	},
	"deps": {
		' + cPkgDepString + '
	}
}
'
	write("+MANIFEST", cManifest)
	write("+DESC", cDesc)
	ok

func DistributeForMobileQt cBaseFolder,cFileName,aOptions
	msg("Prepare RingQt project to distribute for Mobile")
	# Get custom output filename if specified
	cOutput = cFileName
	for x = len(aOptions) to 1 step -1
		cOption = lower(trim(aOptions[x]))
		if left(cOption,8) = "-output="
			cOutput = substr(cOption, 9)
			exit
		ok
	next
	# Delete Files
	if(direxists(:mobile))
		OSDeleteFolder(:mobile)
	ok
	OSCreateOpenFolder(:mobile)
	OSCreateOpenFolder(:qtproject)
	msg("Copy RingQt for Mobile project files...")
	OSCopyFile(exefolder() + "../extensions/android/ringqt/project/*.*" )
	if fexists("project.pro.user")
		OSDeleteFile("project.pro.user")
	ok
	msg("Prepare the Ring Object (*.ringo) file...")
	OSDeleteFile("ringapp.ring")
	OSDeleteFile("ringapp.ringo")
	# Use original filename for .ringo file (generated by Ring compiler)
	cRINGOFile = cBaseFolder+"/"+cFileName+".ringo"
	msg("Get the Ring Object File")
	OSCopyFile(cRINGOFile)
	# But use custom output name in Qt project files
	cProjectRingoName = cOutput+".ringo"
	# Only rename if the names are different
	if cFileName+".ringo" != cProjectRingoName
		OSRenameFile(cFileName+".ringo", cProjectRingoName)
	ok
	write("main.cpp",substr(read("main.cpp"),"ringapp.ringo",cProjectRingoName))
	write("project.qrc",substr(read("project.qrc"),"ringapp.ringo",cProjectRingoName))
	CheckQtResourceFile(cBaseFolder,cOutput,aOptions)
	cMainFile = cBaseFolder+"/"+"main.cpp"
	if fexists(cMainFile)
		msg("We have the Main File : " + cMainFile)
		msg("Copy the Main file to target/mobile/qtproject")
		OSDeleteFile("main.cpp")
		OSCopyFile(cMainFile)
	ok
	msg("Copy Ring and RingQt folders...")
	if isWindows()
		OSCopyFolder(exefolder() + "..\extensions\android\ringqt\project\","ring" )
		OSCopyFolder(exefolder() + "..\extensions\android\ringqt\project\","ringqt" )
	else
		OSCopyFolder(exefolder() + "../extensions/android/ringqt/project/","ring" )
		OSCopyFolder(exefolder() + "../extensions/android/ringqt/project/","ringqt" )
	ok

func DistributeForWebAssemblyQt cBaseFolder,cFileName,aOptions
	msg("Prepare RingQt project to distribute for Web (WebAssembly)")
	# Get custom output filename if specified
	cOutput = cFileName
	for x = len(aOptions) to 1 step -1
		cOption = lower(trim(aOptions[x]))
		if left(cOption,8) = "-output="
			cOutput = substr(cOption, 9)
			exit
		ok
	next
	# Delete Files
	if(direxists(:webassembly))
		OSDeleteFolder(:webassembly)
	ok
	OSCreateOpenFolder(:webassembly)
	OSCreateOpenFolder(:qtproject)
	msg("Copy RingQt for WebAssembly project files...")
	OSCopyFile(exefolder() + "../extensions/webassembly/ringqt/project/*.*" )
	if fexists("project.pro.user")
		OSDeleteFile("project.pro.user")
	ok
	msg("Prepare the Ring Object (*.ringo) file...")
	OSDeleteFile("ringapp.ring")
	OSDeleteFile("ringapp.ringo")
	# Use original filename for .ringo file (generated by Ring compiler)
	cRINGOFile = cBaseFolder+"/"+cFileName+".ringo"
	msg("Get the Ring Object File")
	OSCopyFile(cRINGOFile)
	# But use custom output name in Qt project files
	cProjectRingoName = cOutput+".ringo"
	# Only rename if the names are different
	if cFileName+".ringo" != cProjectRingoName
		OSRenameFile(cFileName+".ringo", cProjectRingoName)
	ok
	write("main.cpp",substr(read("main.cpp"),"ringapp.ringo",cProjectRingoName))
	write("project.qrc",substr(read("project.qrc"),"ringapp.ringo",cProjectRingoName))
	CheckQtResourceFile(cBaseFolder,cOutput,aOptions)
	cMainFile = cBaseFolder+"/"+"main.cpp"
	if fexists(cMainFile)
		msg("We have the Main File : " + cMainFile)
		msg("Copy the Main file to target/webassembly/qtproject")
		OSDeleteFile("main.cpp")
		OSCopyFile(cMainFile)
	ok
	msg("Copy Ring and RingQt folders...")
	if isWindows()
		OSCopyFolder(exefolder() + "..\extensions\webassembly\ringqt\project\","ring" )
		OSCopyFolder(exefolder() + "..\extensions\webassembly\ringqt\project\","ringqt" )
	else
		OSCopyFolder(exefolder() + "../extensions/webassembly/ringqt/project/","ring" )
		OSCopyFolder(exefolder() + "../extensions/webassembly/ringqt/project/","ringqt" )
	ok

func CheckQtResourceFile cBaseFolder,cFileName,aOptions
	cResourceFile = cBaseFolder+"/"+"project.qrc"
	if fexists(cResourceFile)
		msg("We have Qt Resource File : " + cResourceFile)
		msg("Copy the resource file to the Qt project folder")
		OSDeleteFile("project.qrc")
		OSCopyFile(cResourceFile)
		msg("Copy files added to the Resource file")
		cResourceFileContent = read(cResourceFile)
		aResourceFileContent = str2list(cResourceFileContent)
		aFiles = []
		for cItem in aResourceFileContent
			if substr(cItem,"<file>") and substr(cItem,"</file>")
				cFile = cItem 
				cFile = trim(cFile)
				cFile = substr(cFile,char(9),"")
				cFile = substr(cFile,"<file>","")
				cFile = substr(cFile,"</file>","")
				if right(cFile,5) != "ringo"
					aFiles + cFile
				ok
			ok
		next
		for cFile in aFiles 
			msg("Copy File : " + cFile)
			custom_OSCopyFile(cBaseFolder,cFile)
		next
	ok

func custom_OSCopyFile cBaseFolder,cFile
	cDir = currentdir()
	cFolder = justfilepath(cFile)
	if cFolder != NULL
		# Remove last / in the path
		cFolder = left(cFolder,len(cFolder)-1)
		OSCreateOpenFolder(cFolder)
	ok
	OSCopyFile(cBaseFolder+"/"+cFile)
	chdir(cDir)



func CheckNoCCompiler cBaseFolder,cFileName,aOptions
	# If we don't have a C compiler 
	# We copy ring.exe to be app.exe 
	# Then we change app.ringo to ring.ringo 
	cOutput = GetOutputName(aOptions, cFileName)
	cCustomCompiler = ""
	for x = len(aOptions) to 1 step -1
		cOption = lower(trim(aOptions[x]))
		if left(cOption,4) = "-cc="
			cCustomCompiler = substr(cOption, 5)
			exit
		ok
	next
	if isWindows()
		cExeFile = cBaseFolder+"\"+cOutput+".exe"
	else 
		cExeFile = cBaseFolder+"/"+cOutput
	ok
	if fexists(cExeFile)
		msg("Executable file is ready!")
		return False
	ok
	if isWindows()
		cRingOFile = cBaseFolder+"\"+cFileName+".ringo"
	else 
		cRingOFile = cBaseFolder+"/"+cFileName+".ringo"
	ok
	if fexists(cRingOFile)
		if cCustomCompiler != NULL
			msg("No Executable, Looks like we don't have the '" + cCustomCompiler + "' C Compiler!")
		else 
			msg("No Executable, Looks like we don't have a C Compiler!")
		ok
	else 
		msg("No Ring Object File!")
		return False
	ok
	msg("Using the Ring Way to create executable file without a C Compiler!")
	cRingExeFile = exefolder() + "/ring"
	if isWindows() 
		if find(aOptions,"-gui")
			# use ringw.exe if -gui specified
			cRingExeFile += "w.exe"
		else 
			cRingExeFile += ".exe"
		ok
	ok
	OSCopyFile(cRingExeFile)
	if isWindows()
		if find(aOptions,"-gui")
			OSRenameFile("ringw.exe",cOutput+".exe")
		else
			OSRenameFile("ring.exe",cOutput+".exe")
		ok
		OSCopyFile(cBaseFolder+"\"+cFileName+".ringo")
	else 
		OSRenameFile("ring",cOutput)
		OSCopyFile(cBaseFolder+"/"+cFileName+".ringo")
	ok
	OSRenameFile(cFileName+".ringo","ring.ringo")
	return True

func removeTabs cStr
	cOutput = ""
	aList = str2list(cStr)
	for item in aList
		if trim(item) = NULL loop ok
		while left(item,1) = tab
			item = substr(item,2)
		end
		cOutput += item + nl
	next
	return cOutput

# AppImage and App Bundle Functions

func CreateAppImage cAppName, aOptions
	msg("Prepare files to create the AppImage package")
	
	# Go back to the linux directory first
	cLinuxDir = currentdir()
	OSCreateOpenFolder("dist_using_appimage")
	cAppImageDir = currentdir()
	
	# Create AppDir structure
	cAppDirName = cAppName + ".AppDir"
	OSCreateOpenFolder(cAppDirName)
	cAppDirPath = currentdir()
	
	# Create standard directories
	OSCreateOpenFolder("usr")
	cUsrPath = currentdir()
	OSCreateOpenFolder("bin")
	chdir(cUsrPath)
	OSCreateOpenFolder("lib")
	chdir(cAppDirPath)
	
	# Copy executable (go back to linux dir to access dist_using_scripts)
	chdir(cLinuxDir)
	cScriptsPath = "dist_using_scripts"
	if fexists(cScriptsPath + "/bin/" + cAppName)
		chdir(cAppDirPath)
		systemSilent("cp " + cLinuxDir + "/" + cScriptsPath + "/bin/" + cAppName + " usr/bin/")
		systemSilent("chmod +x usr/bin/" + cAppName)
	else
		msg("Warning: Could not find executable at " + cScriptsPath + "/bin/" + cAppName)
		chdir(cAppDirPath)
	ok
	
	# Copy libraries
	chdir(cLinuxDir)
	if direxists(cScriptsPath + "/lib")
		chdir(cAppDirPath)
		systemSilent("cp -a " + cLinuxDir + "/" + cScriptsPath + "/lib/. usr/lib/")
	else
		msg("Warning: Could not find libraries at " + cScriptsPath + "/lib")
		chdir(cAppDirPath)
	ok
	
	# Create desktop file (properly formatted)
	cDesktopFile = "[Desktop Entry]" + nl +
		"Type=Application" + nl +
		"Name=" + cAppName + nl +
		"Exec=" + cAppName + nl +
		"Icon=" + cAppName + nl +
		"Categories=Development;" + nl +
		"Comment=Ring Application" + nl
	write(cAppName + ".desktop", cDesktopFile)
	
	# Create AppRun script
	cAppRunScript = '#!/bin/bash' + nl +
		'HERE="$(dirname "$(readlink -f "${0}")")"/usr' + nl +
		'export LD_LIBRARY_PATH="${HERE}/lib:${LD_LIBRARY_PATH}"' + nl +
		'export PATH="${HERE}/bin:${PATH}"' + nl +
		'cd "${HERE}"' + nl +
		'exec "${HERE}/bin/' + cAppName + '" "$@"' + nl
	write("AppRun", cAppRunScript)
	systemSilent("chmod +x AppRun")
	
	# Create a simple SVG icon directly
	cSvgIcon = RemoveFirstTabs('
		<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
		  <rect width="64" height="64" fill="#4CAF50" rx="8"/>
		  <text x="32" y="40" font-family="Arial" font-size="36" fill="white" text-anchor="middle">R</text>
		</svg>
	',2)
	write(cAppName + ".svg", cSvgIcon)
	
	# Create build script for AppImage
	chdir(cAppImageDir)
	cBuildAppImage = RemoveFirstTabs('
		#!/bin/bash
		echo "Building AppImage for ' + cAppName + '..."

		# Use global appimagetool if available, else download local copy
		if command -v appimagetool >/dev/null 2>&1; then
			APPIMAGETOOL=$(command -v appimagetool)
			echo "Using global appimagetool: $APPIMAGETOOL"
		else
			if [ ! -f appimagetool ]; then
				echo "Downloading appimagetool..."
				wget -O appimagetool https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
				chmod +x appimagetool
			fi
			APPIMAGETOOL=./appimagetool
			echo "Using local appimagetool: $APPIMAGETOOL"
		fi

		# Create AppImage
		echo "Creating AppImage..."
		ARCH=' + GetPackageArch("appimage") + ' $APPIMAGETOOL ' + cAppDirName + ' ' + cAppName + '-' + GetPackageArch("appimage") + '.AppImage

		if [ $? -eq 0 ]; then
			echo "AppImage created successfully: ' + cAppName + '-' + GetPackageArch("appimage") + '.AppImage"
			ls -la ' + cAppName + '-' + GetPackageArch("appimage") + '.AppImage
		else
			echo "Failed to create AppImage"
			echo "Note: You may need to install appimagetool manually"
			echo "Alternative: Use the prepared ' + cAppDirName + ' directory"
		fi
	',2)
	write("build_appimage.sh", cBuildAppImage)
	systemSilent("chmod +x build_appimage.sh")
	
func CreateAppBundle cAppName, aOptions
	msg("Prepare files to create the App Bundle package")
	
	# Store the parent macOS directory before creating the appbundle folder
	cParentDir = currentdir()
	
	OSCreateOpenFolder("dist_using_appbundle")
	cAppBundleDir = currentdir()
	
	# Create .app bundle structure
	cAppBundleName = cAppName + ".app"
	OSCreateOpenFolder(cAppBundleName)
	cAppPath = currentdir()
	
	# Create Contents directory and subdirectories
	OSCreateOpenFolder("Contents")
	cContentsPath = currentdir()

	OSCreateOpenFolder("MacOS")
	chdir(cContentsPath)
	OSCreateOpenFolder("Resources")
	chdir(cContentsPath)
	OSCreateOpenFolder("Frameworks")
	
	# Copy executable to MacOS directory
	chdir(cContentsPath + "/MacOS")
	# Go back to the parent macOS directory to access the bin folder
	chdir(cParentDir)
	if fexists("dist_using_scripts/bin/" + cAppName)
		# Copy from bin directory to MacOS directory
		systemSilent("cp dist_using_scripts/bin/" + cAppName + " " + cContentsPath + "/MacOS/" + cAppName + " 2>/dev/null || true")
		if !fexists(cContentsPath + "/MacOS/" + cAppName)
			msg("Warning: Failed to copy executable to App Bundle")
		ok
	else
		msg("Warning: Could not find executable at dist_using_scripts/bin/" + cAppName)
	ok
	
	# Copy libraries to Frameworks directory
	chdir(cContentsPath + "/Frameworks")
	
	# Go back to the parent macOS directory to access the lib folder
	chdir(cParentDir)
	if direxists("dist_using_scripts/lib")
		systemSilent("cp -r dist_using_scripts/lib/* " + cContentsPath + "/Frameworks/ 2>/dev/null || true")
	else
		msg("Warning: Could not find libraries at dist_using_scripts/lib")
	ok
	
	# Create Info.plist file
	chdir(cContentsPath)
	cInfoPlist = RemoveFirstTabs('
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
		<dict>
		    <key>CFBundleDevelopmentRegion</key>
		    <string>English</string>
		    <key>CFBundleExecutable</key>
		    <string>' + cAppName + '</string>
		    <key>CFBundleGetInfoString</key>
		    <string>Ring Application</string>
		    <key>CFBundleIconFile</key>
		    <string>' + cAppName + '.icns</string>
		    <key>CFBundleIdentifier</key>
		    <string>net.ring-lang.' + cAppName + '</string>
		    <key>CFBundleInfoDictionaryVersion</key>
		    <string>6.0</string>
		    <key>CFBundleName</key>
		    <string>' + cAppName + '</string>
		    <key>CFBundlePackageType</key>
		    <string>APPL</string>
		    <key>CFBundleShortVersionString</key>
		    <string>1.0</string>
		    <key>CFBundleSignature</key>
		    <string>????</string>
		    <key>CFBundleVersion</key>
		    <string>1.0</string>
		    <key>NSHighResolutionCapable</key>
		    <true/>
		    <key>LSMinimumSystemVersion</key>
		    <string>10.12</string>
		</dict>
		</plist>
	',2)
	write("Info.plist", cInfoPlist)
	
	# Create a simple icon (ICNS format placeholder)
	chdir(cContentsPath + "/Resources")
	cResourcesPath = currentdir()
	cIconSetScript = RemoveFirstTabs('
		#!/bin/bash
		echo "Creating App Icon..."

		# Set working directory to Resources path
		cd "#{f1}"

		# Create iconset directory in Resources folder
		mkdir -p ' + cAppName + '.iconset

		# Create a base SVG template
		cat > base_icon.svg <<EOF
<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512">
	 <rect width="512" height="512" fill="#4CAF50" rx="64"/>
	 <text x="256" y="350" font-family="Arial" font-size="256" fill="white" text-anchor="middle">R</text>
</svg>
EOF

		# Try to convert with available tools
		if command -v rsvg-convert >/dev/null 2>&1; then
			echo "Using rsvg-convert to create icons..."
			for size in 16 32 64 128 256 512 1024; do
				rsvg-convert -w ${size} -h ${size} base_icon.svg > ' + cAppName + '.iconset/icon_${size}x${size}.png 2>/dev/null
				if [ ${size} -le 512 ]; then
					rsvg-convert -w $((size*2)) -h $((size*2)) base_icon.svg > ' + cAppName + '.iconset/icon_${size}x${size}@2x.png 2>/dev/null
				fi
			done
		elif command -v convert >/dev/null 2>&1; then
			echo "Using ImageMagick convert to create icons..."
			for size in 16 32 64 128 256 512 1024; do
				convert base_icon.svg -resize ${size}x${size} ' + cAppName + '.iconset/icon_${size}x${size}.png 2>/dev/null
				if [ ${size} -le 512 ]; then
					convert base_icon.svg -resize $((size*2))x$((size*2)) ' + cAppName + '.iconset/icon_${size}x${size}@2x.png 2>/dev/null
				fi
			done
		else
			echo "Neither rsvg-convert nor convert found. Creating minimal icon set..."
			# Create a simple 16x16 icon using basic tools
			echo "Creating minimal 16x16 icon..."
			# Create a simple PPM format image
			cat > ' + cAppName + '.iconset/icon_16x16.ppm <<EOF
P3
16 16
255
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80 76 175 80
EOF
			# Convert PPM to PNG if possible
			if command -v convert >/dev/null 2>&1; then
				convert ' + cAppName + '.iconset/icon_16x16.ppm ' + cAppName + '.iconset/icon_16x16.png 2>/dev/null
				rm -f ' + cAppName + '.iconset/icon_16x16.ppm
			fi
		fi

		# Create ICNS file if iconutil is available
		if command -v iconutil >/dev/null 2>&1; then
			echo "Creating ICNS file..."
			iconutil -c icns ' + cAppName + '.iconset 2>/dev/null
			if [ $? -eq 0 ]; then
				rm -rf ' + cAppName + '.iconset
				echo "Icon created: ' + cAppName + '.icns"
			else
				echo "Failed to create ICNS file, removing iconset directory"
				rm -rf ' + cAppName + '.iconset
			fi
		else
			echo "iconutil not found - removing iconset directory"
			rm -rf ' + cAppName + '.iconset
		fi

		rm -f base_icon.svg
	',2)
	cIconSetScript = substr(cIconSetScript, "#{f1}", cResourcesPath)
	write("create_icon.sh", cIconSetScript)
	systemSilent("chmod +x create_icon.sh")
	systemSilent("./create_icon.sh")
	remove("create_icon.sh")
	
	# Set executable permissions
	chdir(cContentsPath + "/MacOS")
	if fexists(cAppName)
		systemSilent("chmod +x " + cAppName)
	else
		msg("Warning: Could not find " + cAppName + " to set permissions")
	ok
	
	# Create build script
	chdir(cAppBundleDir)
	cBuildBundle = RemoveFirstTabs("#!/bin/bash
		echo
		echo macOS App Bundle created: " + cAppBundleName + "
		echo
		echo To sign the app bundle \(optional\):
		echo '  codesign --force --deep --sign - " + cAppBundleName + "'
		echo
		echo To test the app:
		echo '  open " + cAppBundleName + "'
		echo
		echo To create a DMG installer:
		echo '  hdiutil create -volname '" + cAppName + "' -srcfolder . -ov -format UDZO " + cAppName + ".dmg'
		echo
		ls -la " + cAppBundleName + "
	",2)
	write("bundle_info.sh", cBuildBundle)
	systemSilent("chmod +x bundle_info.sh")

func GetPackageArch cPackageType
	cArch = GetArch()
	switch cArch
	on "x64"
		switch cPackageType
		on "deb" return "amd64"
		on "rpm" return "x86_64"
		on "appimage" return "x86_64"
		on "pkg" return "amd64"
		off
	on "arm64"
		switch cPackageType
		on "deb" return "arm64"
		on "rpm" return "aarch64"
		on "appimage" return "aarch64"
		on "pkg" return "aarch64"
		off
	on "x86"
		switch cPackageType
		on "deb" return "i386"
		on "rpm" return "i686"
		on "appimage" return "i686"
		on "pkg" return "i386"
		off
	on "arm"
		switch cPackageType
		on "deb" return "armhf"
		on "rpm" return "armhfp"
		on "appimage" return "armhf"
		on "pkg" return "armv7"
		off
	other
		return "unknown"
	off
	return "unknown"

